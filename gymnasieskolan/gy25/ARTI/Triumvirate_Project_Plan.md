
# Project Plan: Triumvirate Collaborative Development Framework

**Version:** 1.0
**Date:** 2025-09-30

## 1. Objective

To design and implement a multi-LLM collaborative framework named "Triumvirate." This framework will intelligently orchestrate Gemini (as the Orchestrator), Claude Sonnet 4.5 (as the Architect), and Claude Opus 4.1 (as the Engineer) to automate complex software development tasks. The project's core is to refactor the existing `optimized_integrated_tool.py` script into a master controller that manages this multi-model workflow, maximizing efficiency and output quality by delegating sub-tasks based on each model's identified strengths.

## 2. Model Roles & Responsibilities

Our collaboration has revealed distinct, complementary strengths. The Triumvirate framework will formalize these roles:

### 2.1. Gemini (The Orchestrator)

*   **Role:** Acts as the central controller and executor.
*   **Responsibilities:**
    *   Manages the primary user interface (CLI).
    *   Maintains the project state, including file system operations (`read_file`, `write_file`) and shell command execution (`run_shell_command`).
    *   Decomposes high-level user requests into strategic tasks.
    *   Routes tasks to the appropriate "consultant" LLM (Sonnet or Opus) using the Triumvirate Communication Protocol (TCP).
    *   Synthesizes outputs from consultants into concrete, executable tool calls.
    *   Maintains the "source of truth" for the codebase and project state.

### 2.2. Claude Sonnet 4.5 (The Architect)

*   **Role:** Acts as the high-level planner, reviewer, and conversational refiner.
*   **Strengths:** Context retention, iterative refinement, understanding ambiguity, and collaborative planning.
*   **Responsibilities:**
    *   **Planning:** Generates high-level project plans, file structures, and architectural designs from vague user requests.
    *   **Refinement:** Helps resolve ambiguities in requirements through conversational interaction.
    *   **Review:** Reviews code generated by Opus for architectural consistency, integration issues, and adherence to the overall plan.
    *   **Analysis:** Analyzes existing codebases to inform planning.

### 2.3. Claude Opus 4.1 (The Engineer)

*   **Role:** Acts as the specialist for generating complete, production-ready artifacts in a single shot.
*   **Strengths:** Executing highly-structured, self-contained prompts to produce robust, high-quality code.
*   **Responsibilities:**
    *   **Code Generation:** Writes complete functions, classes, or files based on detailed specifications.
    *   **Algorithm Implementation:** Implements complex algorithms or logic.
    *   **Boilerplate and Tests:** Generates unit tests, configuration files, and other boilerplate code with high fidelity.

## 3. The Triumvirate Communication Protocol (TCP)

A standardized, machine-readable JSON format for inter-model communication. This ensures that requests are structured, clear, and contain all necessary context.

### TCP Schema:

```json
{
  "task_id": "string (UUID for tracking)",
  "initiator": "Gemini",
  "target_consultant": "Sonnet-4.5 | Opus-4.1",
  "request_type": "planning | code_generation | review | analysis",
  "objective": "string (A clear, one-sentence goal)",
  "context": {
    "project_summary": "string (Brief overview of the project)",
    "relevant_files": "object (Content of files, e.g., {'path/to/file.py': 'file_content'})",
    "previous_discussion": "string (For Sonnet, summary of relevant prior conversation)"
  },
  "input_data": "object (e.g., function signatures, data structures)",
  "requirements": {
    "output_format": "string (e.g., 'python_function_string', 'json_plan')",
    "constraints": "string[] (e.g., 'must not use external libraries')",
    "must_include": "string[] (e.g., 'docstrings', 'type_hints')"
  },
  "example": {
    "input": "string",
    "output": "string"
  }
}
```

## 4. `optimized_integrated_tool.py` Refactoring Plan

The existing script will be evolved into a `TriumvirateOrchestrator` class.

### `TriumvirateOrchestrator` Class Structure:

```python
class TriumvirateOrchestrator:
    def __init__(self):
        # Loads its own capabilities and initializes state
        pass

    def execute_user_request(self, user_request: str):
        """Main entry point for a new user request."""
        # 1. Plan the task with Sonnet
        plan = self._consult_architect(user_request)

        # 2. Execute the plan
        for step in plan:
            if step['type'] == 'code_generation':
                # Get code from Opus
                code = self._consult_engineer(step['details'])
                
                # Optional: Review with Sonnet
                review_feedback = self._consult_architect_for_review(code, step['context'])
                
                # Refine and write file
                final_code = self._refine_code(code, review_feedback)
                self.write_file(step['path'], final_code)

            elif step['type'] == 'run_command':
                self.run_shell_command(step['command'])
            
            # ... other step types
    
    def _consult_architect(self, prompt: str) -> dict:
        """Formats and sends a planning request to Sonnet."""
        # Constructs and saves a TCP prompt for Sonnet
        # Returns Sonnet's response (the plan)
        pass

    def _consult_engineer(self, prompt: str) -> str:
        """Formats and sends a code generation request to Opus."""
        # Constructs and saves a TCP prompt for Opus
        # Returns Opus's response (the code)
        pass
    
    # ... other helper methods for file I/O, shell commands, etc.
```

## 5. Sample Workflow Implementation (Proof of Concept)

**User Request:** "Create a simple Flask API with one endpoint `/health` that returns a JSON with `{"status": "ok"}`. Add a `requirements.txt` file."

1.  **Gemini (Orchestrator):** Receives request.
2.  **Gemini -> Sonnet (Architect):** Sends TCP prompt. `request_type: 'planning'`, `objective: 'Create a simple Flask health-check API'`.
3.  **Sonnet -> Gemini:** Responds with a plan:
    ```json
    [
      {"type": "file_creation", "path": "requirements.txt", "content": "Flask"},
      {"type": "code_generation", "path": "app.py", "details": "Create a Flask app with a /health endpoint."}
    ]
    ```
4.  **Gemini (Orchestrator):** Processes plan.
    *   **Step 1:** Executes `write_file('requirements.txt', 'Flask')`.
5.  **Gemini -> Opus (Engineer):**
    *   **Step 2:** Sends TCP prompt. `request_type: 'code_generation'`, `objective: 'Create Flask app'`, `requirements: {'output_format': 'python_function_string'}`.
6.  **Opus -> Gemini:** Responds with the complete `app.py` code.
7.  **Gemini (Orchestrator):** Executes `write_file('app.py', ...)`.
8.  **Gemini (Orchestrator):** Reports completion to the user.

## 6. Success Criteria

*   A functional `TriumvirateOrchestrator` class is implemented.
*   The system can successfully complete the sample workflow described in Section 5.
*   Prompts for Sonnet and Opus are generated automatically based on the TCP.
*   The framework demonstrates a clear advantage over a single-LLM approach by successfully leveraging the specialized roles of each model.
