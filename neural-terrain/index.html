<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Terrain â€” Multi-Model AI Terrain Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --void: #0a0c10;
            --deep: #11141c;
            --panel: #161a24;
            --edge: #1e2330;
            --muted: #3a4055;
            --dim: #6b7394;
            --text: #b0b8d4;
            --bright: #e2e8f8;
            --accent: #4ecdc4;
            --accent-dim: #2a8a84;
            --warm: #f4a261;
            --alert: #e76f51;
            --radius: 8px;
            --mono: 'JetBrains Mono', monospace;
            --sans: 'Outfit', sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { height: 100%; }

        body {
            font-family: var(--sans);
            background: var(--void);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* â”€â”€ Grain overlay â”€â”€ */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.025;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            background-size: 256px;
        }

        /* â”€â”€ Header â”€â”€ */
        .header {
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--edge);
            background: linear-gradient(180deg, rgba(16,20,30,0.95), rgba(10,12,16,0.9));
            backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent), var(--warm));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: var(--void);
            font-family: var(--mono);
        }

        .logo-text {
            font-family: var(--mono);
            font-weight: 600;
            font-size: 1rem;
            color: var(--bright);
            letter-spacing: -0.02em;
        }

        .logo-text span {
            color: var(--dim);
            font-weight: 400;
        }

        .header-meta {
            font-family: var(--mono);
            font-size: 0.7rem;
            color: var(--dim);
            display: flex;
            gap: 1.5rem;
        }

        .header-meta a {
            color: var(--accent-dim);
            text-decoration: none;
            transition: color 0.2s;
        }
        .header-meta a:hover { color: var(--accent); }

        /* â”€â”€ Main layout â”€â”€ */
        .app {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: calc(100vh - 60px);
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }
            .sidebar {
                max-height: 50vh;
                overflow-y: auto;
            }
        }

        /* â”€â”€ Sidebar â”€â”€ */
        .sidebar {
            background: var(--deep);
            border-right: 1px solid var(--edge);
            padding: 1.25rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .section-label {
            font-family: var(--mono);
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--dim);
            padding: 0.75rem 0 0.25rem;
        }

        .section-label:first-child { padding-top: 0; }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 52px;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0;
        }

        .control-label {
            font-size: 0.78rem;
            color: var(--text);
            font-weight: 400;
        }

        .control-value {
            font-family: var(--mono);
            font-size: 0.72rem;
            color: var(--accent);
            text-align: right;
            font-weight: 500;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--edge);
            border-radius: 2px;
            outline: none;
            grid-column: 1 / -1;
            margin-top: -0.25rem;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(78,205,196,0.3);
            transition: transform 0.15s, box-shadow 0.15s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(78,205,196,0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        select {
            background: var(--panel);
            color: var(--bright);
            border: 1px solid var(--edge);
            border-radius: var(--radius);
            padding: 0.4rem 0.6rem;
            font-family: var(--mono);
            font-size: 0.75rem;
            cursor: pointer;
            grid-column: 1 / -1;
            outline: none;
        }
        select:hover { border-color: var(--muted); }
        select:focus { border-color: var(--accent-dim); }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.7rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-family: var(--mono);
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-dim));
            color: var(--void);
        }
        .btn-primary:hover {
            filter: brightness(1.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(78,205,196,0.25);
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            filter: none;
        }

        .btn-secondary {
            background: var(--panel);
            color: var(--text);
            border: 1px solid var(--edge);
        }
        .btn-secondary:hover {
            background: var(--edge);
            color: var(--bright);
        }

        .btn-row {
            display: flex;
            gap: 0.5rem;
            padding-top: 0.5rem;
        }

        .btn-row .btn { flex: 1; }

        /* â”€â”€ Canvas area â”€â”€ */
        .canvas-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
            background:
                radial-gradient(ellipse at 30% 20%, rgba(78,205,196,0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(244,162,97,0.02) 0%, transparent 50%),
                var(--void);
        }

        canvas {
            border: 1px solid var(--edge);
            border-radius: var(--radius);
            box-shadow:
                0 2px 20px rgba(0,0,0,0.4),
                0 0 60px rgba(78,205,196,0.03);
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
        }

        .canvas-info {
            font-family: var(--mono);
            font-size: 0.65rem;
            color: var(--dim);
            margin-top: 1rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-info span { white-space: nowrap; }

        .status {
            font-family: var(--mono);
            font-size: 0.7rem;
            color: var(--accent);
            margin-top: 0.75rem;
            min-height: 1.2em;
        }

        .status.working { color: var(--warm); }

        /* â”€â”€ Model credits â”€â”€ */
        .credits {
            padding: 0.75rem 0 0;
            border-top: 1px solid var(--edge);
            margin-top: 0.5rem;
        }

        .credit-item {
            display: grid;
            grid-template-columns: 8px 1fr;
            gap: 0.5rem;
            align-items: start;
            padding: 0.3rem 0;
            font-size: 0.7rem;
        }

        .credit-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-top: 2px;
        }
        .credit-dot.gemini { background: #4285f4; }
        .credit-dot.codex { background: #10a37f; }
        .credit-dot.grok { background: #e44; }
        .credit-dot.claude { background: var(--accent); }

        .credit-model {
            font-family: var(--mono);
            font-weight: 500;
            color: var(--text);
        }
        .credit-task {
            color: var(--dim);
            font-size: 0.65rem;
        }

        /* â”€â”€ Tooltip â”€â”€ */
        .tooltip {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--edge);
            border-radius: 6px;
            padding: 0.5rem 0.7rem;
            font-family: var(--mono);
            font-size: 0.7rem;
            color: var(--text);
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            display: none;
            white-space: nowrap;
        }
        .tooltip .tt-biome { color: var(--accent); font-weight: 500; }
        .tooltip .tt-val { color: var(--dim); }

        /* â”€â”€ Loading â”€â”€ */
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
        .loading { animation: pulse 1.2s ease-in-out infinite; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon">NT</div>
            <div class="logo-text">neural-terrain <span>v1.0</span></div>
        </div>
        <div class="header-meta">
            <span>Multi-Model AI Orchestration</span>
            <a href="https://github.com/MarkusIsaksson1982" target="_blank">GitHub</a>
        </div>
    </header>

    <div class="app">
        <aside class="sidebar">
            <div class="section-label">Noise Algorithm</div>
            <select id="noiseType">
                <option value="perlin">Perlin Noise (Gemini 3.0 Pro)</option>
                <option value="simplex" selected>Simplex Noise (Gemini 3.0 Pro)</option>
                <option value="blend">Perlin + Simplex Blend</option>
            </select>

            <div class="section-label">Terrain Shape</div>
            <div class="control-row">
                <span class="control-label">Scale</span>
                <span class="control-value" id="scaleVal">50</span>
            </div>
            <input type="range" id="scale" min="10" max="200" value="50" step="5">
            <div class="control-row">
                <span class="control-label">Octaves</span>
                <span class="control-value" id="octavesVal">6</span>
            </div>
            <input type="range" id="octaves" min="1" max="10" value="6" step="1">
            <div class="control-row">
                <span class="control-label">Persistence</span>
                <span class="control-value" id="persistenceVal">0.50</span>
            </div>
            <input type="range" id="persistence" min="10" max="90" value="50" step="5">
            <div class="control-row">
                <span class="control-label">Lacunarity</span>
                <span class="control-value" id="lacunarityVal">2.0</span>
            </div>
            <input type="range" id="lacunarity" min="15" max="35" value="20" step="1">
            <div class="control-row">
                <span class="control-label">Seed</span>
                <span class="control-value" id="seedVal">42</span>
            </div>
            <input type="range" id="seed" min="0" max="999" value="42" step="1">

            <div class="section-label">Erosion (gpt-5.3-codex)</div>
            <div class="control-row">
                <span class="control-label">Iterations</span>
                <span class="control-value" id="erosionItersVal">0</span>
            </div>
            <input type="range" id="erosionIters" min="0" max="8000" value="0" step="500">
            <div class="control-row">
                <span class="control-label">Erosion Strength</span>
                <span class="control-value" id="erodeSpeedVal">0.30</span>
            </div>
            <input type="range" id="erodeSpeed" min="5" max="80" value="30" step="5">

            <div class="section-label">Biome (Grok 4.1)</div>
            <div class="control-row">
                <span class="control-label">Sea Level</span>
                <span class="control-value" id="seaLevelVal">0.35</span>
            </div>
            <input type="range" id="seaLevel" min="10" max="60" value="35" step="1">
            <div class="control-row">
                <span class="control-label">Base Temperature</span>
                <span class="control-value" id="baseTempVal">0.70</span>
            </div>
            <input type="range" id="baseTemp" min="30" max="95" value="70" step="5">
            <div class="control-row">
                <span class="control-label">Moisture Scale</span>
                <span class="control-value" id="moistureScaleVal">80</span>
            </div>
            <input type="range" id="moistureScale" min="20" max="200" value="80" step="10">

            <div class="section-label">Display</div>
            <select id="renderMode">
                <option value="biome" selected>Biome Colors</option>
                <option value="elevation">Elevation (Grayscale)</option>
                <option value="moisture">Moisture Map</option>
                <option value="temperature">Temperature Map</option>
                <option value="erosion_diff">Erosion Difference</option>
            </select>

            <div class="btn-row">
                <button class="btn btn-primary" id="generateBtn">â–¶ Generate</button>
                <button class="btn btn-secondary" id="randomBtn">ðŸŽ²</button>
            </div>

            <div class="credits">
                <div class="section-label">Model Contributions</div>
                <div class="credit-item">
                    <div class="credit-dot gemini"></div>
                    <div><span class="credit-model">Gemini 3.0 Pro</span><br><span class="credit-task">Perlin + Simplex Noise</span></div>
                </div>
                <div class="credit-item">
                    <div class="credit-dot codex"></div>
                    <div><span class="credit-model">gpt-5.3-codex</span><br><span class="credit-task">Hydraulic Erosion</span></div>
                </div>
                <div class="credit-item">
                    <div class="credit-dot grok"></div>
                    <div><span class="credit-model">Grok 4.1</span><br><span class="credit-task">Biome Classification</span></div>
                </div>
                <div class="credit-item">
                    <div class="credit-dot claude"></div>
                    <div><span class="credit-model">Claude Opus 4.6</span><br><span class="credit-task">Orchestration + Integration</span></div>
                </div>
            </div>
        </aside>

        <main class="canvas-wrap">
            <canvas id="terrain" width="512" height="512"></canvas>
            <div class="canvas-info">
                <span id="infoSize">512 Ã— 512</span>
                <span id="infoTime">â€”</span>
                <span id="infoBiomes">â€”</span>
            </div>
            <div class="status" id="status">Ready â€” click Generate</div>
            <div class="tooltip" id="tooltip">
                <span class="tt-biome">â€”</span><br>
                <span class="tt-val">â€”</span>
            </div>
        </main>
    </div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERLIN NOISE â€” Ported from Gemini 3.0 Pro's Python implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PerlinNoise {
    constructor(seed = 0) {
        this.p = this._buildPerm(seed);
    }

    _buildPerm(seed) {
        const arr = Array.from({length: 256}, (_, i) => i);
        // Seeded Fisher-Yates shuffle
        let s = seed | 0;
        for (let i = 255; i > 0; i--) {
            s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
            const j = ((s >>> 0) % (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr.concat(arr);
    }

    _fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    _lerp(t, a, b) { return a + t * (b - a); }

    _grad(hash, x, y) {
        const h = hash & 15;
        switch(h) {
            case 0: return x + y;   case 1: return -x + y;
            case 2: return x - y;   case 3: return -x - y;
            case 4: return x;       case 5: return -x;
            case 6: return y;       case 7: return -y;
            case 8: return x + y;   case 9: return -x + y;
            case 10: return x - y;  case 11: return -x - y;
            case 12: return x;      case 13: return -x;
            case 14: return y;      default: return -y;
        }
    }

    noise(x, y) {
        const ix = Math.floor(x), iy = Math.floor(y);
        const xf = x - ix, yf = y - iy;
        const X = ix & 255, Y = iy & 255;
        const u = this._fade(xf), v = this._fade(yf);
        const p = this.p;
        const A = p[X] + Y, B = p[X + 1] + Y;
        return this._lerp(v,
            this._lerp(u, this._grad(p[A], xf, yf), this._grad(p[B], xf - 1, yf)),
            this._lerp(u, this._grad(p[A + 1], xf, yf - 1), this._grad(p[B + 1], xf - 1, yf - 1))
        );
    }

    octaveNoise(x, y, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
        let total = 0, freq = 1, amp = 1;
        for (let i = 0; i < octaves; i++) {
            total += this.noise(x * freq, y * freq) * amp;
            amp *= persistence;
            freq *= lacunarity;
        }
        return total;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMPLEX NOISE â€” Ported from Gemini 3.0 Pro's Python implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class SimplexNoise {
    constructor(seed = 0) {
        this.F2 = (Math.sqrt(3) - 1) / 2;
        this.G2 = (3 - Math.sqrt(3)) / 6;
        this.GRADS = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[1,0],[-1,0],[0,1],[0,-1],[0,1],[0,-1]];
        this.perm = this._buildPerm(seed);
    }

    _buildPerm(seed) {
        const arr = Array.from({length: 256}, (_, i) => i);
        let s = seed | 0;
        for (let i = 255; i > 0; i--) {
            s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
            const j = ((s >>> 0) % (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr.concat(arr);
    }

    noise(x, y) {
        const s = (x + y) * this.F2;
        const i = Math.floor(x + s), j = Math.floor(y + s);
        const t = (i + j) * this.G2;
        const x0 = x - (i - t), y0 = y - (j - t);
        const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
        const x1 = x0 - i1 + this.G2, y1 = y0 - j1 + this.G2;
        const x2 = x0 - 1 + 2 * this.G2, y2 = y0 - 1 + 2 * this.G2;
        const ii = i & 255, jj = j & 255;
        const p = this.perm;
        let n0 = 0, n1 = 0, n2 = 0;

        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 > 0) { t0 *= t0; const g = this.GRADS[p[ii + p[jj]] % 12]; n0 = t0 * t0 * (g[0]*x0 + g[1]*y0); }
        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 > 0) { t1 *= t1; const g = this.GRADS[p[ii+i1 + p[jj+j1]] % 12]; n1 = t1 * t1 * (g[0]*x1 + g[1]*y1); }
        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 > 0) { t2 *= t2; const g = this.GRADS[p[ii+1 + p[jj+1]] % 12]; n2 = t2 * t2 * (g[0]*x2 + g[1]*y2); }

        return 70.0 * (n0 + n1 + n2);
    }

    octaveNoise(x, y, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
        let total = 0, freq = 1, amp = 1;
        for (let i = 0; i < octaves; i++) {
            total += this.noise(x * freq, y * freq) * amp;
            amp *= persistence;
            freq *= lacunarity;
        }
        return total;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HYDRAULIC EROSION â€” Ported from gpt-5.3-codex's Python implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function erodeHeightmap(hm, w, h, iterations, erodeSpeed = 0.3, seed = 42) {
    const out = new Float32Array(hm);
    if (iterations <= 0 || w < 3 || h < 3) return out;

    // Seeded RNG
    let rngState = seed | 0;
    function rng01() {
        rngState = (rngState * 1664525 + 1013904223) & 0xFFFFFFFF;
        return (rngState >>> 0) / 4294967296;
    }

    // Precompute erosion brush
    const radius = 3;
    const brushOffsets = [], brushWeights = [];
    let brushTotal = 0;
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const dist = Math.sqrt(dx*dx + dy*dy);
            const wt = Math.max(0, radius - dist);
            if (wt > 0) { brushOffsets.push([dx, dy]); brushWeights.push(wt); brushTotal += wt; }
        }
    }
    for (let i = 0; i < brushWeights.length; i++) brushWeights[i] /= brushTotal;

    function getGradient(px, py) {
        px = Math.max(0, Math.min(px, w - 1.0001));
        py = Math.max(0, Math.min(py, h - 1.0001));
        const cx = px | 0, cy = py | 0;
        const fx = px - cx, fy = py - cy;
        const h00 = out[cy*w+cx], h10 = out[cy*w+cx+1];
        const h01 = out[(cy+1)*w+cx], h11 = out[(cy+1)*w+cx+1];
        return {
            gx: (h10-h00)*(1-fy) + (h11-h01)*fy,
            gy: (h01-h00)*(1-fx) + (h11-h10)*fx,
            ht: h00*(1-fx)*(1-fy) + h10*fx*(1-fy) + h01*(1-fx)*fy + h11*fx*fy
        };
    }

    const maxLife = 64, inertia = 0.05, sedCapFactor = 4, minSedCap = 0.01;
    const depositSpeed = 0.3, evapSpeed = 0.01, gravity = 4;

    for (let iter = 0; iter < iterations; iter++) {
        let x = rng01() * (w - 1.001), y = rng01() * (h - 1.001);
        let dirX = 0, dirY = 0, speed = 1, water = 1, sediment = 0;

        for (let step = 0; step < maxLife; step++) {
            const {gx, gy, ht: oldH} = getGradient(x, y);
            dirX = dirX * inertia - gx * (1 - inertia);
            dirY = dirY * inertia - gy * (1 - inertia);
            const len = Math.sqrt(dirX*dirX + dirY*dirY);
            if (len < 1e-12) break;
            dirX /= len; dirY /= len;

            const nx = x + dirX, ny = y + dirY;
            if (nx < 0 || nx >= w-1 || ny < 0 || ny >= h-1) break;

            const newH = getGradient(nx, ny).ht;
            const dh = newH - oldH;
            const sedCap = Math.max(minSedCap, -dh * speed * water * sedCapFactor);

            if (sediment > sedCap || dh > 0) {
                const deposit = dh > 0 ? Math.min(dh, sediment) : (sediment - sedCap) * depositSpeed;
                sediment -= deposit;
                // Bilinear deposit
                const cx = x | 0, cy = y | 0, fx = x - cx, fy = y - cy;
                if (cx >= 0 && cx < w-1 && cy >= 0 && cy < h-1) {
                    out[cy*w+cx] += deposit * (1-fx) * (1-fy);
                    out[cy*w+cx+1] += deposit * fx * (1-fy);
                    out[(cy+1)*w+cx] += deposit * (1-fx) * fy;
                    out[(cy+1)*w+cx+1] += deposit * fx * fy;
                }
            } else if (dh < 0) {
                const amount = Math.min((sedCap - sediment) * erodeSpeed, -dh);
                const bx = x | 0, by = y | 0;
                let eroded = 0;
                for (let i = 0; i < brushOffsets.length; i++) {
                    const px = bx + brushOffsets[i][0], py = by + brushOffsets[i][1];
                    if (px < 0 || px >= w || py < 0 || py >= h) continue;
                    const maxRm = Math.max(0, out[py*w+px] - newH);
                    const take = Math.min(amount * brushWeights[i], maxRm);
                    if (take > 0) { out[py*w+px] -= take; eroded += take; }
                }
                sediment += eroded;
            }

            speed = Math.sqrt(Math.max(0, speed*speed + dh * gravity));
            water *= (1 - evapSpeed);
            x = nx; y = ny;
            if (speed < 1e-10) break;
        }
    }
    return out;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BIOME CLASSIFICATION â€” Ported from Grok 4.1's Python implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BIOME_COLORS = {
    deep_ocean:           [30, 50, 100],
    ocean:                [50, 80, 140],
    beach:                [210, 200, 150],
    scorched:             [100, 90, 80],
    bare:                 [140, 135, 125],
    tundra:               [180, 190, 185],
    snow:                 [240, 245, 250],
    temperate_desert:     [200, 190, 130],
    shrubland:            [140, 165, 110],
    grassland:            [120, 170, 70],
    temperate_forest:     [70, 130, 50],
    temperate_rainforest: [40, 100, 50],
    subtropical_desert:   [215, 185, 110],
    tropical_savanna:     [170, 180, 60],
    tropical_forest:      [50, 120, 40],
    tropical_rainforest:  [30, 90, 45]
};

function classifyBiome(elev, moisture, temp, seaLevel) {
    elev = Math.max(0, Math.min(1, elev));
    moisture = Math.max(0, Math.min(1, moisture));
    temp = Math.max(0, Math.min(1, temp));
    const beach = seaLevel + 0.05;

    if (elev < seaLevel) return elev < seaLevel * 0.5 ? 'deep_ocean' : 'ocean';
    if (elev < beach) return 'beach';

    if (elev > 0.85) {
        if (temp < 0.2) return 'snow';
        if (temp < 0.4) return 'tundra';
        if (moisture < 0.2) return 'bare';
        return 'scorched';
    }
    if (elev > 0.6) {
        if (temp < 0.3) return moisture > 0.5 ? 'tundra' : 'bare';
        if (moisture < 0.2) return 'temperate_desert';
        if (moisture < 0.5) return 'shrubland';
        return 'temperate_forest';
    }
    // Medium elevation
    if (temp > 0.7) {
        if (moisture < 0.2) return 'subtropical_desert';
        if (moisture < 0.5) return 'tropical_savanna';
        if (moisture < 0.75) return 'tropical_forest';
        return 'tropical_rainforest';
    }
    if (temp > 0.4) {
        if (moisture < 0.2) return 'temperate_desert';
        if (moisture < 0.5) return 'grassland';
        if (moisture < 0.75) return 'temperate_forest';
        return 'temperate_rainforest';
    }
    if (moisture < 0.3) return 'bare';
    if (moisture < 0.6) return 'shrubland';
    return 'tundra';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIPELINE â€” Orchestrated by Claude Opus 4.6
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SIZE = 512;
const canvas = document.getElementById('terrain');
const ctx = canvas.getContext('2d');
const imgData = ctx.createImageData(SIZE, SIZE);
const statusEl = document.getElementById('status');
const tooltipEl = document.getElementById('tooltip');

let currentElevation = null;
let currentMoisture = null;
let currentTemperature = null;
let currentBiomes = null;
let currentErosionDiff = null;

function getParams() {
    return {
        noiseType: document.getElementById('noiseType').value,
        scale: +document.getElementById('scale').value,
        octaves: +document.getElementById('octaves').value,
        persistence: +document.getElementById('persistence').value / 100,
        lacunarity: +document.getElementById('lacunarity').value / 10,
        seed: +document.getElementById('seed').value,
        erosionIters: +document.getElementById('erosionIters').value,
        erodeSpeed: +document.getElementById('erodeSpeed').value / 100,
        seaLevel: +document.getElementById('seaLevel').value / 100,
        baseTemp: +document.getElementById('baseTemp').value / 100,
        moistureScale: +document.getElementById('moistureScale').value,
        renderMode: document.getElementById('renderMode').value,
    };
}

function generateTerrain() {
    const p = getParams();
    const btn = document.getElementById('generateBtn');
    btn.disabled = true;
    statusEl.textContent = 'Generating noise...';
    statusEl.className = 'status working';
    const t0 = performance.now();

    // Use requestAnimationFrame to let the UI update
    requestAnimationFrame(() => {
        const perlin = new PerlinNoise(p.seed);
        const simplex = new SimplexNoise(p.seed + 1000);
        const moistureNoise = new SimplexNoise(p.seed + 5000);

        // Generate elevation
        const elev = new Float32Array(SIZE * SIZE);
        let eMin = Infinity, eMax = -Infinity;
        for (let y = 0; y < SIZE; y++) {
            for (let x = 0; x < SIZE; x++) {
                const sx = x / p.scale, sy = y / p.scale;
                let val;
                if (p.noiseType === 'perlin') {
                    val = perlin.octaveNoise(sx, sy, p.octaves, p.persistence, p.lacunarity);
                } else if (p.noiseType === 'simplex') {
                    val = simplex.octaveNoise(sx, sy, p.octaves, p.persistence, p.lacunarity);
                } else {
                    const pv = perlin.octaveNoise(sx, sy, p.octaves, p.persistence, p.lacunarity);
                    const sv = simplex.octaveNoise(sx, sy, p.octaves, p.persistence, p.lacunarity);
                    val = pv * 0.5 + sv * 0.5;
                }
                elev[y * SIZE + x] = val;
                if (val < eMin) eMin = val;
                if (val > eMax) eMax = val;
            }
        }
        // Normalize to [0, 1]
        const eRange = eMax - eMin || 1;
        for (let i = 0; i < elev.length; i++) elev[i] = (elev[i] - eMin) / eRange;

        statusEl.textContent = 'Applying erosion...';

        requestAnimationFrame(() => {
            // Erosion
            const preErosion = new Float32Array(elev);
            let eroded = elev;
            if (p.erosionIters > 0) {
                eroded = erodeHeightmap(elev, SIZE, SIZE, p.erosionIters, p.erodeSpeed, p.seed);
                // Re-normalize after erosion
                let rMin = Infinity, rMax = -Infinity;
                for (let i = 0; i < eroded.length; i++) {
                    if (eroded[i] < rMin) rMin = eroded[i];
                    if (eroded[i] > rMax) rMax = eroded[i];
                }
                const rRange = rMax - rMin || 1;
                for (let i = 0; i < eroded.length; i++) eroded[i] = (eroded[i] - rMin) / rRange;
            }

            // Compute erosion difference
            const erosionDiff = new Float32Array(SIZE * SIZE);
            for (let i = 0; i < erosionDiff.length; i++) erosionDiff[i] = eroded[i] - preErosion[i];

            // Generate moisture map (separate noise layer)
            const moisture = new Float32Array(SIZE * SIZE);
            let mMin = Infinity, mMax = -Infinity;
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    const val = moistureNoise.octaveNoise(x / p.moistureScale, y / p.moistureScale, 4, 0.5, 2.0);
                    moisture[y * SIZE + x] = val;
                    if (val < mMin) mMin = val;
                    if (val > mMax) mMax = val;
                }
            }
            const mRange = mMax - mMin || 1;
            for (let i = 0; i < moisture.length; i++) moisture[i] = (moisture[i] - mMin) / mRange;

            // Generate temperature from elevation
            const temperature = new Float32Array(SIZE * SIZE);
            const landRange = Math.max(1e-6, 1 - p.seaLevel);
            for (let i = 0; i < eroded.length; i++) {
                if (eroded[i] <= p.seaLevel) {
                    temperature[i] = p.baseTemp;
                } else {
                    const normH = (eroded[i] - p.seaLevel) / landRange;
                    temperature[i] = Math.max(0, Math.min(1, p.baseTemp - 0.6 * normH));
                }
            }

            // Classify biomes
            const biomes = new Array(SIZE * SIZE);
            const biomeCounts = {};
            for (let i = 0; i < eroded.length; i++) {
                const b = classifyBiome(eroded[i], moisture[i], temperature[i], p.seaLevel);
                biomes[i] = b;
                biomeCounts[b] = (biomeCounts[b] || 0) + 1;
            }

            // Store for tooltip
            currentElevation = eroded;
            currentMoisture = moisture;
            currentTemperature = temperature;
            currentBiomes = biomes;
            currentErosionDiff = erosionDiff;

            statusEl.textContent = 'Rendering...';

            requestAnimationFrame(() => {
                render(p.renderMode);

                const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
                const uniqueBiomes = Object.keys(biomeCounts).length;
                document.getElementById('infoTime').textContent = `${elapsed}s`;
                document.getElementById('infoBiomes').textContent = `${uniqueBiomes} biomes`;
                statusEl.textContent = `Generated in ${elapsed}s`;
                statusEl.className = 'status';
                btn.disabled = false;
            });
        });
    });
}

function render(mode) {
    const data = imgData.data;
    for (let i = 0; i < SIZE * SIZE; i++) {
        const idx = i * 4;
        let r, g, b;

        if (mode === 'biome') {
            const c = BIOME_COLORS[currentBiomes[i]];
            r = c[0]; g = c[1]; b = c[2];
        } else if (mode === 'elevation') {
            const v = (currentElevation[i] * 255) | 0;
            r = g = b = v;
        } else if (mode === 'moisture') {
            const v = currentMoisture[i];
            r = ((1 - v) * 180) | 0;
            g = ((0.3 + v * 0.4) * 255) | 0;
            b = (v * 220 + 35) | 0;
        } else if (mode === 'temperature') {
            const v = currentTemperature[i];
            r = (v * 230 + 20) | 0;
            g = ((1 - Math.abs(v - 0.5) * 2) * 160) | 0;
            b = ((1 - v) * 200 + 40) | 0;
        } else if (mode === 'erosion_diff') {
            const d = currentErosionDiff[i];
            if (d < 0) {
                const v = Math.min(1, -d * 50);
                r = (v * 230) | 0; g = (50 - v * 30) | 0; b = (50 - v * 30) | 0;
            } else {
                const v = Math.min(1, d * 50);
                r = (50 - v * 30) | 0; g = (50 - v * 30) | 0; b = (v * 230) | 0;
            }
        }

        data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI WIRING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const sliders = [
    ['scale', 'scaleVal', v => v],
    ['octaves', 'octavesVal', v => v],
    ['persistence', 'persistenceVal', v => (v/100).toFixed(2)],
    ['lacunarity', 'lacunarityVal', v => (v/10).toFixed(1)],
    ['seed', 'seedVal', v => v],
    ['erosionIters', 'erosionItersVal', v => v],
    ['erodeSpeed', 'erodeSpeedVal', v => (v/100).toFixed(2)],
    ['seaLevel', 'seaLevelVal', v => (v/100).toFixed(2)],
    ['baseTemp', 'baseTempVal', v => (v/100).toFixed(2)],
    ['moistureScale', 'moistureScaleVal', v => v],
];
sliders.forEach(([id, valId, fmt]) => {
    const el = document.getElementById(id);
    const valEl = document.getElementById(valId);
    el.addEventListener('input', () => { valEl.textContent = fmt(el.value); });
});

// Render mode switch (instant, no regeneration needed)
document.getElementById('renderMode').addEventListener('change', () => {
    if (currentBiomes) render(document.getElementById('renderMode').value);
});

document.getElementById('generateBtn').addEventListener('click', generateTerrain);

document.getElementById('randomBtn').addEventListener('click', () => {
    document.getElementById('seed').value = Math.floor(Math.random() * 1000);
    document.getElementById('seedVal').textContent = document.getElementById('seed').value;
    generateTerrain();
});

// Canvas tooltip
canvas.addEventListener('mousemove', (e) => {
    if (!currentBiomes) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = SIZE / rect.width, scaleY = SIZE / rect.height;
    const px = ((e.clientX - rect.left) * scaleX) | 0;
    const py = ((e.clientY - rect.top) * scaleY) | 0;
    if (px < 0 || px >= SIZE || py < 0 || py >= SIZE) { tooltipEl.style.display = 'none'; return; }
    const i = py * SIZE + px;
    const biome = currentBiomes[i].replace(/_/g, ' ');
    const el = currentElevation[i].toFixed(3);
    const mo = currentMoisture[i].toFixed(3);
    const te = currentTemperature[i].toFixed(3);
    tooltipEl.querySelector('.tt-biome').textContent = biome;
    tooltipEl.querySelector('.tt-val').textContent = `elev ${el}  moist ${mo}  temp ${te}`;
    tooltipEl.style.display = 'block';
    tooltipEl.style.left = (e.clientX + 14) + 'px';
    tooltipEl.style.top = (e.clientY - 40) + 'px';
});
canvas.addEventListener('mouseleave', () => { tooltipEl.style.display = 'none'; });

// Generate on load
generateTerrain();
</script>
</body>
</html>
