<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<pre style="white-space: pre-wrap; font-family: sans-serif;">
---
Type: Code artifact generated by Grok 4 
Author: Grok 4
File name(s): arti_tictactoe_notebook.ipynb
Keywords: [not added yet]
---

{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# ARTI Tic-Tac-Toe AI Agent Notebook\n",
    "\n",
    "This Jupyter notebook demonstrates a minimax-based AI for Tic-Tac-Toe, aligned with the ARTI curriculum (Level 1: Search, problem-solving; Level 2: Optimization, ethics).\n",
    "\n",
    "**Objectives:**\n",
    "- Understand how AI uses search to make decisions.\n",
    "- Compare perfect vs. imperfect AI (with randomness for 'human-like' play).\n",
    "- Discuss ethical implications, like bias in decision rules.\n",
    "\n",
    "**For Teachers:** Use this for interactive lessons—run cells step-by-step. Assess via modifications (e.g., add alpha-beta pruning).\n",
    "\n",
    "**For Students:** Experiment by changing parameters or adding features.\n",
    "\n",
    "From the ARTI chain: Built on Grok 4's Python script, Claude's enhancement plan, and GPT-5's React UI ideas."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "import sys\n",
    "import copy\n",
    "import random\n",
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import clear_output\n",
    "\n",
    "# Game constants\n",
    "BOARD_SIZE = 3\n",
    "EMPTY = ' '\n",
    "PLAYER_X = 'X'  # Human\n",
    "PLAYER_O = 'O'  # AI"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Game Class\n",
    "\n",
    "This cell defines the TicTacToe class with core methods. Run this before playing."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "class TicTacToe:\n",
    "    def __init__(self):\n",
    "        self.board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]\n",
    "        self.current_player = PLAYER_X\n",
    "\n",
    "    def print_board(self):\n",
    "        for row in self.board:\n",
    "            print(' | '.join(row))\n",
    "            print('-' * 5)\n",
    "        print()\n",
    "\n",
    "    def is_valid_move(self, row, col):\n",
    "        return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE and self.board[row][col] == EMPTY\n",
    "\n",
    "    def make_move(self, row, col, player):\n",
    "        if self.is_valid_move(row, col):\n",
    "            self.board[row][col] = player\n",
    "            return True\n",
    "        return False\n",
    "\n",
    "    def check_winner(self):\n",
    "        # Rows, columns, diagonals (same as original)\n",
    "        for i in range(BOARD_SIZE):\n",
    "            if self.board[i][0] == self.board[i][1] == self.board[i][2] != EMPTY:\n",
    "                return self.board[i][0]\n",
    "            if self.board[0][i] == self.board[1][i] == self.board[2][i] != EMPTY:\n",
    "                return self.board[0][i]\n",
    "        if self.board[0][0] == self.board[1][1] == self.board[2][2] != EMPTY:\n",
    "            return self.board[0][0]\n",
    "        if self.board[0][2] == self.board[1][1] == self.board[2][0] != EMPTY:\n",
    "            return self.board[0][2]\n",
    "        if all(cell != EMPTY for row in self.board for cell in row):\n",
    "            return 'DRAW'\n",
    "        return None"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Minimax Algorithm\n",
    "\n",
    "Educational breakdown: Minimax explores all moves recursively. Scores: AI win +10-depth, Human win -10+depth, Draw 0.\n",
    "\n",
    "**Experiment:** Change scores to introduce bias (e.g., favor corners)—discuss ethics."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "    def minimax(self, board, depth, is_maximizing):\n",
    "        winner = self.check_winner()\n",
    "        if winner == PLAYER_O:\n",
    "            return 10 - depth\n",
    "        elif winner == PLAYER_X:\n",
    "            return depth - 10\n",
    "        elif winner == 'DRAW':\n",
    "            return 0\n",
    "\n",
    "        if is_maximizing:\n",
    "            max_eval = -sys.maxsize\n",
    "            for r in range(BOARD_SIZE):\n",
    "                for c in range(BOARD_SIZE):\n",
    "                    if board[r][c] == EMPTY:\n",
    "                        board[r][c] = PLAYER_O\n",
    "                        eval = self.minimax(board, depth + 1, False)\n",
    "                        board[r][c] = EMPTY\n",
    "                        max_eval = max(max_eval, eval)\n",
    "            return max_eval\n",
    "        else:\n",
    "            min_eval = sys.maxsize\n",
    "            for r in range(BOARD_SIZE):\n",
    "                for c in range(BOARD_SIZE):\n",
    "                    if board[r][c] == EMPTY:\n",
    "                        board[r][c] = PLAYER_X\n",
    "                        eval = self.minimax(board, depth + 1, True)\n",
    "                        board[r][c] = EMPTY\n",
    "                        min_eval = min(min_eval, eval)\n",
    "            return min_eval"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Find Best Move (with Imperfect Option)\n",
    "\n",
    "Adds 'imperfect' mode: With probability, picks random move instead of best. Toggle via parameter."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "    def find_best_move(self, imperfect=False, imperfection_prob=0.3):\n",
    "        best_score = -sys.maxsize\n",
    "        best_move = None\n",
    "        possible_moves = []\n",
    "        for r in range(BOARD_SIZE):\n",
    "            for c in range(BOARD_SIZE):\n",
    "                if self.board[r][c] == EMPTY:\n",
    "                    self.board[r][c] = PLAYER_O\n",
    "                    score = self.minimax(self.board, 0, False)\n",
    "                    self.board[r][c] = EMPTY\n",
    "                    possible_moves.append(((r, c), score))\n",
    "                    if score > best_score:\n",
    "                        best_score = score\n",
    "                        best_move = (r, c)\n",
    "        if imperfect and random.random() < imperfection_prob:\n",
    "            return random.choice([m[0] for m in possible_moves])\n",
    "        print('Move Evaluations:', possible_moves)  # For teaching: Show scores\n",
    "        return best_move"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Visualize Game Tree (Extension)\n",
    "\n",
    "Simple graph of possible moves (first level). For ARTI Level 2: Optimization."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "def visualize_game_tree(game):\n",
    "    G = nx.DiGraph()\n",
    "    root = str(game.board)\n",
    "    G.add_node(root)\n",
    "    for r in range(BOARD_SIZE):\n",
    "        for c in range(BOARD_SIZE):\n",
    "            if game.is_valid_move(r, c):\n",
    "                temp_board = copy.deepcopy(game.board)\n",
    "                temp_board[r][c] = PLAYER_O\n",
    "                child = str(temp_board)\n",
    "                G.add_edge(root, child)\n",
    "    pos = nx.spring_layout(G)\n",
    "    nx.draw(G, pos, with_labels=True, node_size=500, font_size=8)\n",
    "    plt.show()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Play the Game\n",
    "\n",
    "Run this cell to start. Set `imperfect=True` for varied play.\n",
    "\n",
    "**Input:** Enter moves as row,col (e.g., 0,0)."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "def play_game(imperfect=False):\n",
    "    game = TicTacToe()\n",
    "    while True:\n",
    "        clear_output(wait=True)\n",
    "        game.print_board()\n",
    "        winner = game.check_winner()\n",
    "        if winner:\n",
    "            if winner == 'DRAW':\n",
    "                print(\"It's a draw!\")\n",
    "            else:\n",
    "                print(f\"{winner} wins!\")\n",
    "            break\n",
    "        if game.current_player == PLAYER_X:\n",
    "            try:\n",
    "                row, col = map(int, input(\"Your move (row,col): \").split(','))\n",
    "                if not game.make_move(row, col, PLAYER_X):\n",
    "                    print(\"Invalid move.\")\n",
    "                    continue\n",
    "            except:\n",
    "                print(\"Invalid input.\")\n",
    "                continue\n",
    "        else:\n",
    "            print(\"AI thinking...\")\n",
    "            row, col = game.find_best_move(imperfect=imperfect)\n",
    "            game.make_move(row, col, PLAYER_O)\n",
    "            print(f\"AI moves to {row},{col}\")\n",
    "        game.current_player = PLAYER_O if game.current_player == PLAYER_X else PLAYER_X\n",
    "\n",
    "# Example: play_game(imperfect=True)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Discussion and Assessment\n",
    "\n",
    "1. How does adding randomness change the game? (Ethics: Fairness vs. engagement)\n",
    "2. Visualize the tree: Run `visualize_game_tree(game)` after a move.\n",
    "3. Project: Implement alpha-beta pruning and compare runtime.\n",
    "\n",
    "**Assessment Rubric (from Claude):**\n",
    "- Explain minimax (0-5 pts)\n",
    "- Modify code successfully (0-10 pts)\n",
    "- Ethical analysis (0-5 pts)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}  
</pre>  
</body>
</html>
