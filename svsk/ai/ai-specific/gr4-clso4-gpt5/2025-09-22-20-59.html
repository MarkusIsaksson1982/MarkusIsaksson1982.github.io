<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<pre style="white-space: pre-wrap; font-family: sans-serif;">
---
Type: Code artifact generated by Grok 4 
Author: Grok 4
File name(s): grok4_tictactoe_ai_agent.py
Keywords: [not added yet]
---

# grok4_tictactoe_ai_agent.py
# Educational tool for ARTI curriculum: Demonstrates AI game agents using minimax search.
# Aligns with ARTI Level 1: Search techniques, problem-solving, and comparing human/AI intelligence.
# Students can run this to play against the AI, then modify for experiments (e.g., add randomness for "imperfect" AI).
# Ethical note: Discuss how deterministic AI might be "fair" but lacks human intuitionâ€”potential biases if trained on data.

import sys
import copy

# Game board representation (3x3 grid)
BOARD_SIZE = 3
EMPTY = ' '
PLAYER_X = 'X'  # Human player
PLAYER_O = 'O'  # AI player

class TicTacToe:
    def __init__(self):
        self.board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
        self.current_player = PLAYER_X  # Human starts

    def print_board(self):
        """Prints the current board state."""
        for row in self.board:
            print(' | '.join(row))
            print('-' * 5)
        print()

    def is_valid_move(self, row, col):
        """Checks if a move is valid."""
        return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE and self.board[row][col] == EMPTY

    def make_move(self, row, col, player):
        """Places a mark on the board."""
        if self.is_valid_move(row, col):
            self.board[row][col] = player
            return True
        return False

    def check_winner(self):
        """Checks for a winner or draw."""
        # Check rows, columns, diagonals
        for i in range(BOARD_SIZE):
            if self.board[i][0] == self.board[i][1] == self.board[i][2] != EMPTY:
                return self.board[i][0]
            if self.board[0][i] == self.board[1][i] == self.board[2][i] != EMPTY:
                return self.board[0][i]
        if self.board[0][0] == self.board[1][1] == self.board[2][2] != EMPTY:
            return self.board[0][0]
        if self.board[0][2] == self.board[1][1] == self.board[2][0] != EMPTY:
            return self.board[0][2]
        # Check for draw
        if all(cell != EMPTY for row in self.board for cell in row):
            return 'DRAW'
        return None

    def minimax(self, board, depth, is_maximizing):
        """Minimax algorithm for AI decision-making.
        Educational breakdown:
        - Recursively explores all possible moves.
        - Maximizes AI's score (O wins: +1, X wins: -1, draw: 0).
        - Depth tracks turns to prioritize quicker wins.
        """
        winner = self.check_winner()
        if winner == PLAYER_O:
            return 10 - depth  # AI win: higher score for shallower depth
        elif winner == PLAYER_X:
            return depth - 10  # Human win: lower score
        elif winner == 'DRAW':
            return 0

        if is_maximizing:  # AI's turn (maximize)
            max_eval = -sys.maxsize
            for r in range(BOARD_SIZE):
                for c in range(BOARD_SIZE):
                    if board[r][c] == EMPTY:
                        board[r][c] = PLAYER_O
                        eval = self.minimax(board, depth + 1, False)
                        board[r][c] = EMPTY
                        max_eval = max(max_eval, eval)
            return max_eval
        else:  # Human's turn (minimize)
            min_eval = sys.maxsize
            for r in range(BOARD_SIZE):
                for c in range(BOARD_SIZE):
                    if board[r][c] == EMPTY:
                        board[r][c] = PLAYER_X
                        eval = self.minimax(board, depth + 1, True)
                        board[r][c] = EMPTY
                        min_eval = min(min_eval, eval)
            return min_eval

    def find_best_move(self):
        """Finds the best move for AI using minimax."""
        best_score = -sys.maxsize
        best_move = None
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                if self.board[r][c] == EMPTY:
                    self.board[r][c] = PLAYER_O
                    score = self.minimax(self.board, 0, False)
                    self.board[r][c] = EMPTY
                    if score > best_score:
                        best_score = score
                        best_move = (r, c)
        return best_move

def play_game():
    game = TicTacToe()
    print("Welcome to Tic-Tac-Toe AI Agent Demo for ARTI!")
    print("You are X (human). AI is O.")
    print("Enter moves as row,col (0-2).")
    print("Educational tip: Watch how AI uses search to predict outcomes.")

    while True:
        game.print_board()
        winner = game.check_winner()
        if winner:
            if winner == 'DRAW':
                print("It's a draw!")
            else:
                print(f"{winner} wins!")
            break

        if game.current_player == PLAYER_X:
            # Human move
            try:
                row, col = map(int, input("Your move (row,col): ").split(','))
                if not game.make_move(row, col, PLAYER_X):
                    print("Invalid move. Try again.")
                    continue
            except ValueError:
                print("Invalid input. Use format: row,col")
                continue
        else:
            # AI move
            print("AI thinking...")
            row, col = game.find_best_move()
            game.make_move(row, col, PLAYER_O)
            print(f"AI moves to {row},{col}")

        # Switch players
        game.current_player = PLAYER_O if game.current_player == PLAYER_X else PLAYER_X

    # Post-game educational prompts
    print("\nARTI Discussion Questions:")
    print("1. How does minimax mimic human planning? Where does it differ?")
    print("2. If we added biased rules (e.g., favoring corners), what ethical issues arise?")
    print("3. Extend this: Implement alpha-beta pruning to optimize search (ARTI Level 2).")

if __name__ == "__main__":
    play_game()
</pre>  
</body>
</html>
